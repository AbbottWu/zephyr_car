#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/drivers/i2c.h>
#include <zephyr/sys/ring_buffer.h>
#include "motor.h"
LOG_MODULE_REGISTER(main, CONFIG_LOG_DEFAULT_LEVEL);

#define I2CSENSOR DT_ALIAS(lightsensor)

RING_BUF_DECLARE(sensor_buf, 20);

enum Sensor_Status
{
    Sensor_OK,
    Sensor_DEVICE_INVALID,
    Sensor,
    Sensor_DATA_ERROR
};

void info_log_wait(const char *str)
{
    LOG_INF("%s", str);
    k_msleep(1000);
}

Sensor_Status i2c_ping(const i2c_dt_spec i2c)
{
    uint8_t *buffer;
    uint32_t real_size = ring_buf_put_claim(&sensor_buf, &buffer, 1);
    if (real_size != 1)
    {
        return Sensor_DATA_ERROR;
    }
    if (i2c_is_ready_dt(&i2c) == true)
    {
        LOG_INF("buffer width: %d", sizeof(*buffer));
        info_log_wait("device Ready");
        if (i2c_reg_read_byte_dt(&i2c, 0xAA, buffer) == 0)
        {
            ring_buf_put_finish(&sensor_buf, 1);
            info_log_wait("read ok");
            ring_buf_get(&sensor_buf, buffer, 1);
            if (buffer[0] == 0x66)
            {
                return Sensor_OK;
            }
            else
            {
                return Sensor_DATA_ERROR;
            }
        }
        else
        {
            info_log_wait("read error");
            return Sensor;
        }
    }
    return Sensor_DEVICE_INVALID;
}

Sensor_Status digital_read_to_buffer(const i2c_dt_spec *i2c, uint8_t *buffer)
{
    if (i2c_is_ready_dt(i2c) == true)
    {
        if (i2c_reg_read_byte_dt(i2c, 0xDD, buffer) == 0)
        {
            return Sensor_OK;
        }
        else
        {
            return Sensor;
        }
    }
    return Sensor_DEVICE_INVALID;
}

Sensor_Status analogs_read_to_buffer(const i2c_dt_spec *i2c, uint8_t *buffer)
{
    if (i2c_is_ready_dt(i2c) == true)
    {
        if (i2c_burst_read_dt(i2c, 0xB1, buffer, 8) == 0)
        {
            return Sensor_OK;
        }
        else
        {
            return Sensor;
        }
    }
    return Sensor_DEVICE_INVALID;
}

Sensor_Status digital_continous_set(const i2c_dt_spec *i2c, uint8_t *buffer)
{
    if (i2c_is_ready_dt(i2c) == true)
    {
        buffer[0] = 0xDD;
        if (i2c_write_dt(i2c, buffer, 1) == 0)
        {
            return Sensor_OK;
        }
        else
        {
            return Sensor;
        }
    }
    return Sensor_DEVICE_INVALID;
}

Sensor_Status digital_continous_read(const i2c_dt_spec *i2c, uint8_t *buffer)
{
    if (i2c_is_ready_dt(i2c) == true)
    {
        if (i2c_read_dt(i2c, buffer, 1) == 0)
        {
            return Sensor_OK;
        }
        else
        {
            return Sensor;
        }
    }
    return Sensor_DEVICE_INVALID;
}

Sensor_Status analogs_continous_read(const i2c_dt_spec *i2c, uint8_t *buffer)
{
    if (i2c_is_ready_dt(i2c) == true)
    {
        if (i2c_read_dt(i2c, buffer, 8) == 0)
        {
            return Sensor_OK;
        }
        else
        {
            return Sensor;
        }
    }
    return Sensor_DEVICE_INVALID;
}

Sensor_Status analogs_continous_set(const i2c_dt_spec *i2c, uint8_t *buffer)
{
    if (i2c_is_ready_dt(i2c) == true)
    {
        buffer[0] = 0xB0;
        if (i2c_write_dt(i2c, buffer, 1) == 0)
        {
            return Sensor_OK;
        }
        else
        {
            return Sensor;
        }
    }
    return Sensor_DEVICE_INVALID;
}

void sensor_init(void)
{
    const i2c_dt_spec i2c = I2C_DT_SPEC_GET(I2CSENSOR);
    for (int i = 0; i < 4; i++)
    {
        LOG_INF("Wating to ping");
        k_msleep(1000);
    }
    int ret = 0;
    do
    {
        ret = i2c_ping(i2c);
        switch (ret)
        {
        case Sensor_OK:
            LOG_INF("I2C PING OK");
            break;
        case Sensor_DEVICE_INVALID:
            LOG_ERR("I2C DEVICE INVALID");
            break;
        case Sensor:
            LOG_ERR("I2C IO ERROR");
            break;
        case Sensor_DATA_ERROR:
            LOG_ERR("I2C DATA ERROR");
            break;
        }
        k_msleep(100);
    } while (ret != Sensor_OK);
}

int main(void)
{

    // buf[0] = 0;
    sensor_init();
    for (int i = 0; i < 20000; i++)
    {
        LOG_INF("I2C OK");
        k_msleep(100);
    }

    // while (true)
    // {
    //     k_msleep(1000);
    // }
    return 0;
}